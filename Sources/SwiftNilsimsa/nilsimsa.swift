//
//  nilsimsa.swift
//
//
//  Created by Ludwig Friborg on 2020-10-25.
//

import Foundation

class Nilsimsa {
    private static let TRAN = [0x02,0xD6,0x9E,0x6F,0xF9,0x1D,0x04,0xAB,0xD0,0x22,0x16,0x1F,0xD8,0x73,0xA1,0xAC,0x3B,0x70,0x62,0x96,0x1E,0x6E,0x8F,0x39,0x9D,0x05,0x14,0x4A,0xA6,0xBE,0xAE,0x0E,0xCF,0xB9,0x9C,0x9A,0xC7,0x68,0x13,0xE1,0x2D,0xA4,0xEB,0x51,0x8D,0x64,0x6B,0x50,0x23,0x80,0x03,0x41,0xEC,0xBB,0x71,0xCC,0x7A,0x86,0x7F,0x98,0xF2,0x36,0x5E,0xEE,0x8E,0xCE,0x4F,0xB8,0x32,0xB6,0x5F,0x59,0xDC,0x1B,0x31,0x4C,0x7B,0xF0,0x63,0x01,0x6C,0xBA,0x07,0xE8,0x12,0x77,0x49,0x3C,0xDA,0x46,0xFE,0x2F,0x79,0x1C,0x9B,0x30,0xE3,0x00,0x06,0x7E,0x2E,0x0F,0x38,0x33,0x21,0xAD,0xA5,0x54,0xCA,0xA7,0x29,0xFC,0x5A,0x47,0x69,0x7D,0xC5,0x95,0xB5,0xF4,0x0B,0x90,0xA3,0x81,0x6D,0x25,0x55,0x35,0xF5,0x75,0x74,0x0A,0x26,0xBF,0x19,0x5C,0x1A,0xC6,0xFF,0x99,0x5D,0x84,0xAA,0x66,0x3E,0xAF,0x78,0xB3,0x20,0x43,0xC1,0xED,0x24,0xEA,0xE6,0x3F,0x18,0xF3,0xA0,0x42,0x57,0x08,0x53,0x60,0xC3,0xC0,0x83,0x40,0x82,0xD7,0x09,0xBD,0x44,0x2A,0x67,0xA8,0x93,0xE0,0xC2,0x56,0x9F,0xD9,0xDD,0x85,0x15,0xB4,0x8A,0x27,0x28,0x92,0x76,0xDE,0xEF,0xF8,0xB2,0xB7,0xC9,0x3D,0x45,0x94,0x4B,0x11,0x0D,0x65,0xD5,0x34,0x8B,0x91,0x0C,0xFA,0x87,0xE9,0x7C,0x5B,0xB1,0x4D,0xE5,0xD4,0xCB,0x10,0xA2,0x17,0x89,0xBC,0xDB,0xB0,0xE2,0x97,0x88,0x52,0xF7,0x48,0xD3,0x61,0x2C,0x3A,0x2B,0xD1,0x8C,0xFB,0xF1,0xCD,0xE4,0x6A,0xE7,0xA9,0xFD,0xC4,0x37,0xC8,0xD2,0xF6,0xDF,0x58,0x72,0x4E]
    
    private static let POPC = [0x00,0x01,0x01,0x02,0x01,0x02,0x02,0x03,0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04,0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x04,0x05,0x05,0x06,0x05,0x06,0x06,0x07,0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x04,0x05,0x05,0x06,0x05,0x06,0x06,0x07,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x04,0x05,0x05,0x06,0x05,0x06,0x06,0x07,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x04,0x05,0x05,0x06,0x05,0x06,0x06,0x07,0x04,0x05,0x05,0x06,0x05,0x06,0x06,0x07,0x05,0x06,0x06,0x07,0x06,0x07,0x07,0x08]
    
    private static func unicode_value(char: Character) -> Int {
        let scalars = char.unicodeScalars

        return Int(scalars[scalars.startIndex].value)
    }
    
    private static func tran_hash(a: Int, b: Int, c: Int, n: Int) -> Int {
        return (((TRAN[(a+n) & 255] ^ TRAN[b] * (n+n+1)) + TRAN[(c)^TRAN[n]]) & 255)
    }
    
    public static func hash(input: String) -> String {
        var num_char = 0
        var num_trigrams = 0
        var accumulator = [Int](repeating: 0, count: 256)
        var window: [Int] = []
        
        // Process window
        for char in input {
            num_char += 1
            let c = Nilsimsa.unicode_value(char: char)
            
            if (window.count > 1) {
                accumulator[Nilsimsa.tran_hash(a: c, b: window[0], c: window[1], n: 0)] += 1
            }
            
            if (window.count > 2) {
                accumulator[Nilsimsa.tran_hash(a: c, b: window[0], c: window[2], n: 1)] += 1
                accumulator[Nilsimsa.tran_hash(a: c, b: window[1], c: window[2], n: 2)] += 1
            }
            
            if (window.count > 3) {
                accumulator[Nilsimsa.tran_hash(a: c, b: window[0], c: window[3], n: 3)] += 1
                accumulator[Nilsimsa.tran_hash(a: c, b: window[1], c: window[3], n: 4)] += 1
                accumulator[Nilsimsa.tran_hash(a: c, b: window[2], c: window[3], n: 5)] += 1
                accumulator[Nilsimsa.tran_hash(a: window[3], b: window[0], c: c, n: 6)] += 1
                accumulator[Nilsimsa.tran_hash(a: window[3], b: window[2], c: c, n: 7)] += 1
            }
            
            if (window.count < 4) {
                window.insert(c, at: 0)
            } else {
                window = [c, window[0], window[1], window[2]]
            }
        }
        
        // Compute digest
        if (num_char == 3) {
            num_trigrams = 1
        } else if (num_char == 4) {
            num_trigrams = 4
        } else if (num_char > 4) {
            num_trigrams = 8 * num_char - 28
        }
        
        let threshold = Double(num_trigrams) / 256.0

        var digest = [Int](repeating: 0, count: 32)
        for (i, a) in accumulator.enumerated() {
            if (Double(a) > threshold) {
                digest[i >> 3] += 1 << (i & 7)      // equivalent to i/8, 2**(i mod 7)
            }
        }
        
        var out = ""
        for i in digest.reversed() {
            out += String(format:"%02X", i)
        }
        
        return out
    }
    
    public static func compare(in_1: String, in_2: String) -> Double {
        var digest_1: [Int] = []
        for i in 0...(in_1.count / 2 - 1) {
            let string = in_1[in_1.index(in_1.startIndex, offsetBy: i*2)..<in_1.index(in_1.startIndex, offsetBy: (i*2 + 2))]
            let value = Int(UInt8(string, radix: 16)!)
            digest_1.append(value)
        }
        
        var digest_2: [Int] = []
        for i in 0...(in_2.count / 2 - 1) {
            let string = in_2[in_2.index(in_2.startIndex, offsetBy: i*2)..<in_2.index(in_2.startIndex, offsetBy: (i*2 + 2))]
            let value = Int(UInt8(string, radix: 16)!)
            digest_2.append(value)
        }
    
        
        var bit_diff = 0
        for (n, d) in digest_1.enumerated() {
            bit_diff += POPC[255 & d ^ digest_2[n]]
        }
        
        return (256.0 - Double(bit_diff)) / 256.0
    }
}
